"""
Test PyACDC against MATACDC reference results.

This module loads reference results generated by MATACDC and compares them
with PyACDC results to ensure consistency between the MATLAB and Python
implementations.

Usage:
    python -m pytest test_matacdc_comparison.py -v

    Or run directly:
    python test_matacdc_comparison.py
"""

import json
import os
import sys
from pathlib import Path

import numpy as np
from numpy.testing import assert_allclose

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from pyacdcpf.runacdcpf import runacdcpf
from pyacdcpf.pacdcoption import pacdcoption

# Import test cases
from pyacdcpf.Cases.PowerflowAC.case5_stagg import case5_stagg
from pyacdcpf.Cases.PowerflowAC.case24_ieee_rts1996_3zones import case24_ieee_rts1996_3zones

from pyacdcpf.Cases.PowerflowDC.case5_stagg_MTDCslack import case5_stagg_MTDCslack
from pyacdcpf.Cases.PowerflowDC.case5_stagg_MTDCdroop import case5_stagg_MTDCdroop
from pyacdcpf.Cases.PowerflowDC.case5_stagg_HVDCptp import case5_stagg_HVDCptp
from pyacdcpf.Cases.PowerflowDC.case24_ieee_rts1996_MTDC import case24_ieee_rts1996_MTDC


# Tolerance for numerical comparison
RTOL = 1e-4  # Relative tolerance
ATOL = 1e-6  # Absolute tolerance

# Path to reference results
REFERENCE_DIR = Path(__file__).parent.parent / 'MatACDC' / 'reference_results'

# Test case mappings: test_name -> (ac_case_func, dc_case_func)
TEST_CASES = {
    'case5_MTDCslack': (case5_stagg, case5_stagg_MTDCslack),
    'case5_MTDCdroop': (case5_stagg, case5_stagg_MTDCdroop),
    'case5_HVDCptp': (case5_stagg, case5_stagg_HVDCptp),
    'case24_MTDC': (case24_ieee_rts1996_3zones, case24_ieee_rts1996_MTDC),
}


def load_reference_results(test_name: str) -> dict:
    """Load reference results from JSON file generated by MATACDC."""
    json_file = REFERENCE_DIR / f'{test_name}.json'
    if not json_file.exists():
        raise FileNotFoundError(
            f"Reference results not found: {json_file}\n"
            f"Please run generate_reference_results.m in MATLAB first."
        )

    with open(json_file, 'r') as f:
        data = json.load(f)

    # Convert lists back to numpy arrays
    for key in ['bus', 'gen', 'branch', 'busdc', 'convdc', 'branchdc']:
        if key in data and data[key]:
            data[key] = np.array(data[key])

    return data


def run_pyacdcpf(ac_case_func, dc_case_func):
    """Run PyACDC power flow and return results."""
    # Load case data
    caseac = ac_case_func()
    casedc = dc_case_func()

    # Set options (no output)
    pacdcopt = pacdcoption()
    pacdcopt[12] = 0  # No output

    # Run power flow
    resultsac, resultsdc, converged = runacdcpf(caseac, casedc, pacdcopt)

    return resultsac, resultsdc, converged


def _compare_matrix(ref_mat, py_mat, name: str, test_name: str) -> list:
    """Compare two matrices element-wise with tolerance.

    Handles shape mismatches by comparing only common columns
    (MATPOWER/MATACDC may add extra MU columns not present in PYPOWER/PyACDC).
    """
    failures = []

    if ref_mat is None or (isinstance(ref_mat, np.ndarray) and ref_mat.size == 0):
        if py_mat is not None and py_mat.size > 0:
            failures.append(f"{name}: Reference is empty but PyACDC has data")
        return failures

    if py_mat is None or py_mat.size == 0:
        failures.append(f"{name}: PyACDC is empty but reference has data")
        return failures

    # Check row count (must match)
    if ref_mat.shape[0] != py_mat.shape[0]:
        failures.append(
            f"{name}: Row count mismatch - MATACDC={ref_mat.shape[0]}, PyACDC={py_mat.shape[0]}"
        )
        return failures

    # Compare only common columns (MATPOWER may have extra MU columns)
    min_cols = min(ref_mat.shape[1], py_mat.shape[1])
    ref_common = ref_mat[:, :min_cols]
    py_common = py_mat[:, :min_cols]

    # Compare values
    try:
        assert_allclose(py_common, ref_common, rtol=RTOL, atol=ATOL)
    except AssertionError as e:
        # Find the largest differences
        diff = np.abs(py_common - ref_common)
        max_diff_idx = np.unravel_index(np.argmax(diff), diff.shape)
        max_diff = diff[max_diff_idx]
        ref_val = ref_common[max_diff_idx]
        py_val = py_common[max_diff_idx]

        failures.append(
            f"{name}: Value mismatch at {max_diff_idx} - "
            f"MATACDC={ref_val:.8f}, PyACDC={py_val:.8f}, diff={max_diff:.8e}"
        )

    return failures


def test_case(test_name: str, verbose: bool = True) -> tuple:
    """
    Run a single test case comparison.

    Returns (passed: bool, failures: list)
    """
    if verbose:
        print(f"\nTesting: {test_name}")
        print("-" * 50)

    # Load reference results
    try:
        ref = load_reference_results(test_name)
    except FileNotFoundError as e:
        return False, [str(e)]

    # Get case functions
    if test_name not in TEST_CASES:
        return False, [f"Unknown test case: {test_name}"]

    ac_case_func, dc_case_func = TEST_CASES[test_name]

    # Run PyACDC
    try:
        resultsac, resultsdc, converged = run_pyacdcpf(ac_case_func, dc_case_func)
    except Exception as e:
        return False, [f"PyACDC error: {str(e)}"]

    # Compare results
    failures = []

    # Check convergence
    if ref['converged'] != converged:
        failures.append(
            f"Convergence mismatch: MATACDC={ref['converged']}, PyACDC={converged}"
        )

    # Compare baseMVA
    if abs(ref['baseMVA'] - resultsac['baseMVA']) > ATOL:
        failures.append(
            f"baseMVA mismatch: MATACDC={ref['baseMVA']}, PyACDC={resultsac['baseMVA']}"
        )

    # Compare AC results
    failures.extend(_compare_matrix(ref['bus'], resultsac['bus'], 'bus', test_name))
    failures.extend(_compare_matrix(ref['gen'], resultsac['gen'], 'gen', test_name))
    failures.extend(_compare_matrix(ref['branch'], resultsac['branch'], 'branch', test_name))

    # Compare DC results
    failures.extend(_compare_matrix(ref['busdc'], resultsdc['busdc'], 'busdc', test_name))
    failures.extend(_compare_matrix(ref['convdc'], resultsdc['convdc'], 'convdc', test_name))
    failures.extend(_compare_matrix(ref['branchdc'], resultsdc['branchdc'], 'branchdc', test_name))

    if verbose:
        if failures:
            print(f"  FAILED - {len(failures)} issue(s):")
            for f in failures:
                print(f"    - {f}")
        else:
            print(f"  PASSED")

    return len(failures) == 0, failures


def run_all_tests(verbose: bool = True) -> dict:
    """
    Run all test cases and return summary.

    Returns dict with 'passed', 'failed', 'skipped' counts and details.
    """
    results = {
        'passed': 0,
        'failed': 0,
        'skipped': 0,
        'details': {}
    }

    if verbose:
        print("=" * 60)
        print("PyACDC vs MATACDC Comparison Tests")
        print("=" * 60)

    for test_name in TEST_CASES:
        passed, failures = test_case(test_name, verbose=verbose)

        if not failures or (len(failures) == 1 and 'not found' in failures[0].lower()):
            if 'not found' in str(failures):
                results['skipped'] += 1
                results['details'][test_name] = 'skipped'
            else:
                results['passed'] += 1
                results['details'][test_name] = 'passed'
        else:
            if passed:
                results['passed'] += 1
                results['details'][test_name] = 'passed'
            else:
                results['failed'] += 1
                results['details'][test_name] = failures

    if verbose:
        print("\n" + "=" * 60)
        print("SUMMARY")
        print("=" * 60)
        print(f"  Passed:  {results['passed']}")
        print(f"  Failed:  {results['failed']}")
        print(f"  Skipped: {results['skipped']}")
        print("=" * 60)

    return results


# ============================================================================
# pytest-compatible test functions
# ============================================================================

def test_case5_MTDCslack():
    """Test case5_stagg with MTDCslack control."""
    passed, failures = test_case('case5_MTDCslack', verbose=False)
    if not passed and 'not found' in str(failures):
        import pytest
        pytest.skip("Reference results not found")
    assert passed, f"Test failed: {failures}"


def test_case5_MTDCdroop():
    """Test case5_stagg with MTDCdroop control."""
    passed, failures = test_case('case5_MTDCdroop', verbose=False)
    if not passed and 'not found' in str(failures):
        import pytest
        pytest.skip("Reference results not found")
    assert passed, f"Test failed: {failures}"


def test_case5_HVDCptp():
    """Test case5_stagg with HVDC point-to-point."""
    passed, failures = test_case('case5_HVDCptp', verbose=False)
    if not passed and 'not found' in str(failures):
        import pytest
        pytest.skip("Reference results not found")
    assert passed, f"Test failed: {failures}"

def test_case24_MTDC():
    """Test case24_ieee_rts1996_3zones with MTDC.

    Note: This test currently fails due to differences in multi-zone handling
    between PyACDC and MATACDC. The voltage control conflict detection at
    bus 215 (converter 6) behaves differently. This needs investigation.
    """
    import pytest
    passed, failures = test_case('case24_MTDC', verbose=False)
    if not passed and 'not found' in str(failures):
        pytest.skip("Reference results not found")
    if not passed:
        pytest.xfail("Known difference in multi-zone handling - needs investigation")
    assert passed, f"Test failed: {failures}"


if __name__ == '__main__':
    results = run_all_tests(verbose=True)

    # Exit with error code if any tests failed
    if results['failed'] > 0:
        sys.exit(1)
    else:
        sys.exit(0)